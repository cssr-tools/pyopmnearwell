<%
import math as mt
%>-- Copyright (C) 2025 NORCE
-- This deck was generated by pyopmnearwell https://github.com/cssr-tools/pyopmnearwell
----------------------------------------------------------------------------
RUNSPEC
----------------------------------------------------------------------------
DIMENS 
% if dic['grid']=='core':
${dic['nocells'][0]} ${dic['nocells'][1]} ${dic['nocells'][2]} /
% else:
${max(dic['nocells'][0],dic['nocells'][1])} ${dic['nocells'][1]} ${dic['nocells'][2]} /
% endif

WATER
GAS
H2STORE
DISGASW
BIOFILM

METRIC

START
1 JAN 2000 /
% if dic['grid']=='radial':

RADIAL
% endif

EQLDIMS
/

TABDIMS
${(dic["hysteresis"]+1)*(dic['satnum']+dic['perforations'][0])} /
% if dic["hysteresis"]!=0:

SATOPTS
HYSTER /
% endif

WELLDIMS
6 ${dic['nocells'][2]} 6 6 /

UNIFOUT
----------------------------------------------------------------------------
GRID
----------------------------------------------------------------------------
% if dic['write']==1:
INIT
% else:
GRIDFILE
0 0 /
% endif
% if dic["fluxnum"]:

INCLUDE
FLUXNUM.INC /
% endif

INCLUDE
GEOLOGY.INC /
% if dic["pvmult"]>0:
----------------------------------------------------------------------------
EDIT
----------------------------------------------------------------------------
INCLUDE
MULTPV.INC /
% endif
----------------------------------------------------------------------------
PROPS
----------------------------------------------------------------------------
INCLUDE
TABLES.INC /
% if dic["hysteresis"]!=0:

EHYSTR
1 ${0 if dic["hysteresis"].upper()=="CARLSON" else 2} 2* KR /
% endif

BIOFPARA
-- BDEN DEATH GROWTH HALF YIELD FACTOR ATACH DETRAT DETEXP UREA HALF CDEN YUTOC
% for i in range(dic["satnum"]):
${dic['biof'][int(dic["layers"][i])][0]} ${dic['biof'][int(dic["layers"][i])][1]} ${dic['biof'][int(dic["layers"][i])][2]} ${dic['biof'][int(dic["layers"][i])][3]} ${dic['biof'][int(dic["layers"][i])][4]} 1 ${dic['biof'][int(dic["layers"][i])][5]} ${dic['biof'][int(dic["layers"][i])][6]} ${dic['biof'][int(dic["layers"][i])][7]} 0 0 0 0 /
% endfor

INCLUDE
PERMFACT.INC /

% if dic["pcfact"]>0:
INCLUDE
PCFACT.INC /
% endif

% if dic["rockcomp"]>0:
ROCK
276 ${dic["rockcomp"]} /
% endif
% if dic["salinity"]>0:

SALINITY
${dic["salinity"]} /
% endif
% if dic["hysteresis"]!=0 or dic["fluxnum"]:
----------------------------------------------------------------------------
REGIONS
----------------------------------------------------------------------------
% if dic["hysteresis"]!=0 and dic["fluxnum"]:
COPY
FLUXNUM SATNUM /
FLUXNUM IMBNUM /
/

ADD
IMBNUM ${len(dic["rock"])} /
/
% elif dic["fluxnum"]:
COPY
FLUXNUM SATNUM /
/
% else:
IMBNUM
${dic['nocells'][0]*dic['nocells'][1]*dic['nocells'][2]}*2 /
% endif
% endif
----------------------------------------------------------------------------
SOLUTION
----------------------------------------------------------------------------
EQUIL
0 ${dic['pressure']} ${mt.floor(dic["initialphase"]*dic['dims'][2])} 0 0 0 1 1 0 /

RTEMPVD
${"".join([' ' for _ in range(len(str(dic['dims'][2]))-1)])}0 ${dic['temperature'][0]}
${dic['dims'][2]} ${dic['temperature'][1]} /

EQUALS
% for i in range(dic['nocells'][2]):
SBIOF ${dic['biof'][int(dic["layers"][i])][8]} 4* ${i+1} ${i+1} /
% endfor
/
% if dic['write']==1:

RPTRST 
BASIC=2 DEN FLOWS /
% endif
----------------------------------------------------------------------------
SUMMARY
----------------------------------------------------------------------------
PERFORMA
FGMIP
FGMIT
FGMPT
FGIP
FWIP
FMBIP
FGMIR
FGMPR
FPR 
FGIP
FWIP
FGIR
FWIR
FGIT
FGPT
FWIT
WGIR
/
WGPR
/
WGIT
/
WGPT
/
WBHP
/
RPR
/
RWIP
/
RGIP
/
WWPR
/
WPI
/
----------------------------------------------------------------------------
SCHEDULE
----------------------------------------------------------------------------
% if dic['write']==1:
RPTRST 
BASIC=2 DEN FLOWS /
% endif

WELSPECS
INJ0 G1 1 ${1+mt.floor(dic['nocells'][2]/2)} 1* GAS 2* STOP ${'NO' if dic["xflow"]>0 else ''} /
PRO0 G1 1 ${1+mt.floor(dic['nocells'][2]/2)} 1* GAS 2* STOP ${'NO' if dic["xflow"]>0 else ''} /
/
COMPDAT
INJ0 1 ${1+mt.floor(dic['nocells'][1]/2)} ${1+mt.floor(dic['nocells'][1]/2)} ${1+mt.floor(dic['nocells'][2]/2)} OPEN 1* ${dic["confact"]} /
PRO0 1 ${1+mt.floor(dic['nocells'][1]/2)} ${1+mt.floor(dic['nocells'][1]/2)} ${1+mt.floor(dic['nocells'][2]/2)} OPEN 1* ${dic["confact"]} /
/
% for j in range(len(dic['inj'])):

% if dic["tuning"]:
TUNING
1E-02 ${dic['inj'][j][2]} 1E-10 2* 1E-12 /
/
/
% endif
WCONINJE
% if dic['inj'][j][3]>0:
INJ0 GAS ${'OPEN' if dic['inj'][j][4]>0 else 'SHUT'} RATE ${f"{dic['inj'][j][4] / 0.0850397:E}"} 1* 480 /
% else:
INJ0 WATER ${'OPEN' if dic['inj'][j][4]>0 else 'SHUT'} RATE ${f"{dic['inj'][j][4] / 998.108:E}"} 1* 480 /
% endif
/
WCONPROD
PRO0 ${'OPEN' if dic['inj'][j][4] < 0 else 'SHUT'} GRAT 2* ${f"{abs(dic['inj'][j][4]) / 0.0850397:E}"} 2* ${dic['inj'][j][5] if dic['inj'][j][4] < 0 else ''} /
/
WECON
PRO0 1* ${f"{dic['econ']*abs(dic['inj'][j][4]) / 0.0850397:E}"} /
/
TSTEP
${f"{round(dic['inj'][j][0]/dic['inj'][j][1])}*" if round(dic['inj'][j][0]/dic['inj'][j][1])>1 else ""}${dic['inj'][j][1]} /
% endfor